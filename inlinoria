local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local gameName = game:GetService('MarketplaceService'):GetProductInfo(game.PlaceId).Name

local Window = Library:CreateWindow({
    Title = "z2v9's menu | " .. gameName,
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Aim Assist'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aim Assist')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Silent Aim')
local LeftGroupBox2 = Tabs.Main:AddLeftGroupbox('Aim Assist Prediction')
local LeftGroupBox3 = Tabs.Main:AddLeftGroupbox('Aim Assist Smoothing')

local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local CoreGui = game:GetService('CoreGui')

local function calculateFOVRadius(fovValue)
    -- Convert FOV value to actual screen radius
    -- FOV 1-90: Use proper angular calculation
    -- FOV 90-1100: Use linear interpolation to full screen
    
    if not fovValue or fovValue <= 0 then return 1 end
    
    if fovValue <= 90 then
        -- For small FOVs, use angular calculation for precision
        local fovRadians = math.rad(fovValue)
        local screenRadius = math.tan(fovRadians / 2) * Camera.ViewportSize.X / 2
        return math.max(screenRadius, 1)
    else
        -- For large FOVs, interpolate between 90-degree radius and full screen
        local fov90Radius = math.tan(math.rad(90) / 2) * Camera.ViewportSize.X / 2
        local fullScreenRadius = Camera.ViewportSize.X / 2
        
        -- Linear interpolation from 90 to 1100
        local normalizedLargeFOV = (fovValue - 90) / (1100 - 90)
        local interpolatedRadius = fov90Radius + (fullScreenRadius - fov90Radius) * normalizedLargeFOV
        
        return math.max(interpolatedRadius, 1)
    end
end

local function isTargetInFOV(targetPosition, fovValue)
    -- Check if target is within FOV using screen distance
    if not targetPosition or not fovValue or fovValue <= 0 then return false end
    
    local screenPos, onScreen = Camera:WorldToScreenPoint(targetPosition)
    if not onScreen then return false end
    
    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
    local screenPos2D = Vector2.new(screenPos.X, screenPos.Y)
    local distance = (mousePos - screenPos2D).Magnitude
    
    local maxDistance = calculateFOVRadius(fovValue)
    return distance <= maxDistance
end

local AimAssistInstance = {}
local fov = nil
local LockedTarget = nil

local SilentAimInstance = {}
local silentFov = nil
local silentTracer = nil
local SilentLockedTarget = nil
local angleData = {angle = 0, distance = 0}

LeftGroupBox:AddToggle('AimAssistEnabled', {
    Text = 'Enabled',
    Default = false,
    Tooltip = 'Enable/disable aim assist functionality'
})

Toggles.AimAssistEnabled:AddKeyPicker('AimKey', {
    Default = 'C',
    Mode = 'Toggle',
    Text = 'Aim Assist',
    NoUI = false,
})

LeftGroupBox:AddSlider('FOV', {
    Text = 'FOV',
    Default = 500,
    Min = 1,
    Max = 1100,
    Rounding = 0,
    Tooltip = 'Field of view for target detection'
})

LeftGroupBox:AddToggle('FOVVisible', {
    Text = 'FOV Visible',
    Default = false,
    Tooltip = 'Show FOV circle'
})

LeftGroupBox:AddDropdown('HitPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 1,
    Text = 'Hit Part',
    Tooltip = 'Target body part'
})

LeftGroupBox:AddToggle('ClosestMode', {
    Text = 'Closest Mode',
    Default = false,
    Tooltip = 'Target closest body part instead of specific part'
})

LeftGroupBox:AddToggle('IncludeNPCs', {
    Text = 'Include NPCs',
    Default = true,
    Tooltip = 'Target NPCs/bots (may reduce performance)'
})

LeftGroupBox:AddToggle('WallCheck', {
    Text = 'Wall Check',
    Default = true,
    Tooltip = 'Only target visible players, stop aiming when target goes behind wall'
})

RightGroupBox:AddToggle('SilentAimEnabled', {
    Text = 'Enabled',
    Default = false,
    Tooltip = 'Enable/disable silent aim functionality'
}):AddKeyPicker('SilentAimKey', {
    Default = 'Q',
    Mode = 'Toggle',
    Text = 'Silent Aim',
    NoUI = false,
})

RightGroupBox:AddDropdown('TargetMode', {
    Values = {'Auto', 'Target'},
    Default = 1,
    Text = 'Target Mode',
    Tooltip = 'Auto = targets based on mouse/FOV | Target = requires key press'
})

RightGroupBox:AddSlider('SilentFOV', {
    Text = 'FOV',
    Default = 1000,
    Min = 1,
    Max = 1100,
    Rounding = 0,
    Tooltip = 'Field of view for silent aim'
})

RightGroupBox:AddToggle('SilentFOVVisible', {
    Text = 'FOV Visible',
    Default = false,
    Tooltip = 'Show silent aim FOV circle'
})

RightGroupBox:AddSlider('SilentXPrediction', {
    Text = 'X Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'X-axis prediction value'
})

RightGroupBox:AddSlider('SilentYPrediction', {
    Text = 'Y Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'Y-axis prediction value'
})

RightGroupBox:AddDropdown('SilentHitPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 1,
    Text = 'Hit Part',
    Tooltip = 'Target body part for silent aim'
})

RightGroupBox:AddToggle('SilentClosestMode', {
    Text = 'Closest Mode',
    Default = false,
    Tooltip = 'Target closest body part instead of specific part'
})

RightGroupBox:AddToggle('AntiCurveEnabled', {
    Text = 'Anti Curve',
    Default = false,
    Tooltip = 'Enable anti-curve / resolver functionality'
})

RightGroupBox:AddSlider('MaxAngle', {
    Text = 'Max Angle',
    Default = 7.67,
    Min = 0,
    Max = 45,
    Rounding = 2,
    Tooltip = 'Maximum angle for anti-curve'
})

RightGroupBox:AddSlider('DistanceThreshold', {
    Text = 'Distance Threshold',
    Default = 50,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Tooltip = 'Distance threshold for anti-curve activation'
})

RightGroupBox:AddToggle('VisualizeAntiCurve', {
    Text = 'Visualize Anti Curve',
    Default = false,
    Tooltip = 'Show anti-curve debug information'
})

LeftGroupBox2:AddSlider('XPrediction', {
    Text = 'X Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'X-axis bullet prediction value'
})

LeftGroupBox2:AddSlider('YPrediction', {
    Text = 'Y Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'Y-axis bullet prediction value'
})

-- removed ZPrediction

LeftGroupBox3:AddSlider('XSmoothing', {
    Text = 'X Smoothing',
    Default = 0.07,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Tooltip = '1.0 = sharpest, 0.01 = smoothest'
})

LeftGroupBox3:AddSlider('YSmoothing', {
    Text = 'Y Smoothing',
    Default = 0.07,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Tooltip = '1.0 = sharpest, 0.01 = smoothest'
})

-- removed ZSmoothing

-- removed easing controls

-- removed humanizer controls

-- removed humanizer samples


local function resolveGuiParent()
    local ok, hui = pcall(function()
        return gethui and gethui()
    end)
    if ok and hui then return hui end
    local pg = LocalPlayer:FindFirstChildWhichIsA('PlayerGui')
    if pg then return pg end
    return CoreGui
end

local function createFovCircle()
    local wrapper = {}
    if Drawing then
        local circle = Drawing.new('Circle')
        circle.Thickness = 1
        circle.Filled = false
        circle.Transparency = 1
        function wrapper:SetRadius(r)
            circle.Radius = r
        end
        function wrapper:SetPosition(v2)
            circle.Position = v2
        end
        function wrapper:SetVisible(v)
            circle.Visible = v
        end
        function wrapper:SetColor(c)
            circle.Color = c
        end
        function wrapper:Remove()
            if circle then circle:Remove() end
        end
        return wrapper
    else
        local gui = Instance.new('ScreenGui')
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false
        gui.Name = 'AimAssistFOV'
        gui.Parent = resolveGuiParent()
        local frame = Instance.new('Frame')
        frame.BackgroundTransparency = 1
        frame.AnchorPoint = Vector2.new(0.5, 0.5)
        frame.Size = UDim2.fromOffset(0, 0)
        frame.Position = UDim2.fromOffset(0, 0)
        frame.Parent = gui
        local stroke = Instance.new('UIStroke')
        stroke.Thickness = 1
        stroke.Parent = frame
        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = frame
        function wrapper:SetRadius(r)
            frame.Size = UDim2.fromOffset(r * 2, r * 2)
        end
        function wrapper:SetPosition(v2)
            frame.Position = UDim2.fromOffset(v2.X, v2.Y)
        end
        function wrapper:SetVisible(v)
            frame.Visible = v
        end
        function wrapper:SetColor(c)
            stroke.Color = c
        end
        function wrapper:Remove()
            if gui then gui:Destroy() end
        end
        return wrapper
    end
end

local function createSilentFovCircle()
    local wrapper = {}
    if Drawing then
        local circle = Drawing.new('Circle')
        circle.Thickness = 1
        circle.Filled = false
        circle.Transparency = 1
        function wrapper:SetRadius(r)
            circle.Radius = calculateFOVRadius(r)
        end
        function wrapper:SetPosition(v2)
            local mousePos = UserInputService:GetMouseLocation()
            circle.Position = Vector2.new(mousePos.X, mousePos.Y)
        end
        function wrapper:SetVisible(v)
            circle.Visible = v
        end
        function wrapper:SetColor(c)
            circle.Color = c
        end
        function wrapper:Remove()
            if circle then circle:Remove() end
        end
        return wrapper
    else
        local gui = Instance.new('ScreenGui')
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false
        gui.Name = 'SilentAimFOV'
        gui.Parent = resolveGuiParent()
        local frame = Instance.new('Frame')
        frame.BackgroundTransparency = 1
        frame.AnchorPoint = Vector2.new(0.5, 0.5)
        frame.Size = UDim2.fromOffset(0, 0)
        frame.Position = UDim2.fromOffset(0, 0)
        frame.Parent = gui
        local stroke = Instance.new('UIStroke')
        stroke.Thickness = 1
        stroke.Parent = frame
        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = frame
        function wrapper:SetRadius(r)
            local radius = calculateFOVRadius(r)
            frame.Size = UDim2.fromOffset(radius * 2, radius * 2)
        end
        function wrapper:SetPosition(v2)
            local mousePos = UserInputService:GetMouseLocation()
            frame.Position = UDim2.fromOffset(mousePos.X, mousePos.Y)
        end
        function wrapper:SetVisible(v)
            frame.Visible = v
        end
        function wrapper:SetColor(c)
            stroke.Color = c
        end
        function wrapper:Remove()
            if gui then gui:Destroy() end
        end
        return wrapper
    end
end

local function getClosestPart(character)
    if not character then return nil end
    
    local parts = {}
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            table.insert(parts, part)
        end
    end
    
    local closestPart = nil
    local closestDist = math.huge
    
    for _, part in pairs(parts) do
        local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position)
        if onScreen then
            local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPart = part
            end
        end
    end
    
    return closestPart
end

local function getClosestPartToCrosshair(character)
    if not character then return nil end
    
    local parts = {}
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            table.insert(parts, part)
        end
    end
    
    local closestPart = nil
    local closestAngle = math.huge
    local camPos = Camera.CFrame.Position
    local camLook = Camera.CFrame.LookVector
    
    for _, part in pairs(parts) do
        local direction = (part.Position - camPos).Unit
        local dot = camLook:Dot(direction)
        local angle = math.acos(math.clamp(dot, -1, 1))
        
        if angle < closestAngle then
            closestAngle = angle
            closestPart = part
        end
    end
    
    return closestPart
end

local function isVisible(targetPart, targetCharacter)
    if not Toggles.WallCheck.Value then return true end
    if not targetPart or not targetCharacter then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local distance = direction.Magnitude
    direction = direction.Unit
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetCharacter}
    rayParams.IgnoreWater = true
    
    local rayResult = workspace:Raycast(origin, direction * distance, rayParams)
    
    if not rayResult then
        return true
    end
    
    if rayResult.Instance then
        local hitParent = rayResult.Instance.Parent
        if hitParent == targetCharacter or rayResult.Instance == targetPart then
            return true
        end
        
        if hitParent and hitParent:IsA('Accessory') then
            local accessoryParent = hitParent.Parent
            if accessoryParent == targetCharacter then
                return true
            end
        end
    end
    
    return false
end

-- removed humanizer logic

local function getValidPlayers()
    local validPlayers = {}
    local hitPartValue = Options.HitPart.Value
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild('Humanoid')
            local rootPart = character:FindFirstChild('HumanoidRootPart')
            if humanoid and rootPart and humanoid.Health > 0 then
                local targetPart = character:FindFirstChild(hitPartValue) or character:FindFirstChild('Head') or rootPart
                if targetPart then
                    table.insert(validPlayers, { player = player, character = character, targetPart = targetPart })
                end
            end
        end
    end
    
    if Toggles.IncludeNPCs.Value then
        local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
        if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
            local targetPart = dummy:FindFirstChild(hitPartValue) or dummy:FindFirstChild('Head') or dummy.HumanoidRootPart
                    if targetPart then
                table.insert(validPlayers, { player = nil, character = dummy, targetPart = targetPart })
            end
        end
    end
    
    return validPlayers
end

local function initializeAimAssist()
    if AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    
    AimAssistInstance = {}
    
    fov = createSilentFovCircle()
    fov:SetRadius(Options.FOV.Value)
    fov:SetColor(Color3.fromRGB(0, 255, 0))
    fov:SetVisible(Toggles.FOVVisible.Value)
    fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
    AimAssistInstance.fov = fov
    
    AimAssistInstance.connections = {}
    
    local lastFOVRadius = Options.FOV.Value
    local lastFOVVisible = Toggles.FOVVisible.Value
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if fov then
            fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
            local currentVisible = Toggles.FOVVisible.Value
            local currentRadius = Options.FOV.Value
            if currentVisible ~= lastFOVVisible then
                fov:SetVisible(currentVisible)
                lastFOVVisible = currentVisible
            end
            if currentRadius ~= lastFOVRadius then
                fov:SetRadius(currentRadius)
                lastFOVRadius = currentRadius
            end
        end
    end)
    
    table.insert(AimAssistInstance.connections, renderConnection)
    
    local function findClosestTarget()
        local validPlayers = getValidPlayers()
        if #validPlayers == 0 then return nil end
        
        local closestDist = math.huge
        local bestTarget = nil
        local mousePos = Vector2.new(Mouse.X, Mouse.Y)
        
        for _, playerData in pairs(validPlayers) do
            local fovValue = Options.FOV and Options.FOV.Value or 500
            if isTargetInFOV(playerData.targetPart.Position, fovValue) then
                local screenPos, onScreen = Camera:WorldToScreenPoint(playerData.targetPart.Position)
                if onScreen then
                    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
                    local screenPos2D = Vector2.new(screenPos.X, screenPos.Y)
                    local dist = (mousePos - screenPos2D).Magnitude
                    
                    if dist < closestDist then
                        closestDist = dist
                        bestTarget = playerData
                    end
                end
            end
        end
        
        return bestTarget
    end
    
    local function isTargetValid(target)
        if not target or not target.character or not target.targetPart then return false end
        if not target.character.Parent then return false end
        
        local humanoid = target.character:FindFirstChild('Humanoid')
        if not humanoid or humanoid.Health <= 0 then return false end
        
        if not isVisible(target.targetPart, target.character) then return false end
        
        return true
    end
    
    local function getKeyState()
        local mode = Options.AimKey.Mode
        local key = Options.AimKey.Value
        
        if mode == 'Always' then
            return true
        elseif mode == 'Hold' then
            if key == 'None' then return false end
            
            if key == 'MB1' or key == 'MB2' then
                return key == 'MB1' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                    or key == 'MB2' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
            else
                return UserInputService:IsKeyDown(Enum.KeyCode[key])
            end
        else
            return Options.AimKey.Toggled or false
        end
    end
    
    local lastActiveState = false
    
    local aimConnection = RunService.RenderStepped:Connect(function(dt)
        local keyActive = getKeyState()
        
        if keyActive and not lastActiveState then
            LockedTarget = findClosestTarget()
            if fov then
                fov:SetColor(Color3.fromRGB(255, 0, 0))
            end
        elseif not keyActive and lastActiveState then
            LockedTarget = nil
            if fov then
                fov:SetColor(Color3.fromRGB(0, 255, 0))
            end
        end
        
        lastActiveState = keyActive
        
        if not keyActive then return end
        if not LockedTarget then return end
        
        if not isTargetValid(LockedTarget) then
            LockedTarget = findClosestTarget()
            if not LockedTarget then
                if fov then
                    fov:SetColor(Color3.fromRGB(0, 255, 0))
                end
                return
            end
        end
        
        local targetChar = LockedTarget.character
        if not targetChar then return end
        
        local targetPart = LockedTarget.targetPart
        
        if Toggles.ClosestMode.Value then
            targetPart = getClosestPartToCrosshair(targetChar)
            if not targetPart then
                local rootPart = targetChar:FindFirstChild('HumanoidRootPart')
                targetPart = targetChar:FindFirstChild('Head') or rootPart
            end
        end
        
        if not targetPart then return end
        
        local xPred = Options.XPrediction.Value
        local yPred = Options.YPrediction.Value
        local zPred = xPred
        
        local velocity = targetPart.AssemblyLinearVelocity
        local predictedPos = targetPart.Position + (velocity * Vector3.new(xPred, yPred, zPred))
        
        local currentCam = Camera.CFrame
        local targetCFrame = CFrame.new(currentCam.Position, predictedPos)
        
        local xSmooth = Options.XSmoothing.Value
        local ySmooth = Options.YSmoothing.Value
        local avgSmooth = (xSmooth + ySmooth) * 0.5
        
        local smoothness = math.clamp(avgSmooth, 0, 1)
        
        Camera.CFrame = currentCam:Lerp(targetCFrame, smoothness)
    end)
    
    table.insert(AimAssistInstance.connections, aimConnection)
    
end

Toggles.AimAssistEnabled:OnChanged(function()
    if Toggles.AimAssistEnabled.Value then
        LockedTarget = nil
        initializeAimAssist()
    else
        LockedTarget = nil
        if AimAssistInstance.fov then
            AimAssistInstance.fov:Remove()
        end
        if AimAssistInstance.connections then
            for _, connection in pairs(AimAssistInstance.connections) do
                if connection and connection.Disconnect then
                    connection:Disconnect()
                end
            end
        end
        if AimAssistInstance.hook then
            restoremetamethod(game, '__index', AimAssistInstance.hook)
        end
    end
end)

local function applyAntiCurve(targetPosition, cameraPosition)
    if not Toggles.AntiCurveEnabled.Value then
        angleData.angle = 0
        angleData.distance = (targetPosition - cameraPosition).Magnitude
        return targetPosition
    end
    
    local maxAngle = math.rad(Options.MaxAngle.Value)
    local distance = (targetPosition - cameraPosition).Magnitude
    
    local crosshairRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
    local targetDirection = (targetPosition - cameraPosition).Unit
    local crosshairDirection = crosshairRay.Direction
    
    local dotProduct = crosshairDirection:Dot(targetDirection)
    local actualAngle = math.acos(math.clamp(dotProduct, -1, 1))
    local actualAngleDegrees = math.deg(actualAngle)
    
    if math.random() < 0.3 then
        local randomAngleX = (math.random() - 0.5) * maxAngle
        local randomAngleY = (math.random() - 0.5) * maxAngle
        
        local rightVector = Camera.CFrame.RightVector
        local upVector = Camera.CFrame.UpVector
        
        local offsetX = rightVector * math.sin(randomAngleX) * distance * 0.1
        local offsetY = upVector * math.sin(randomAngleY) * distance * 0.1
        
        local curvedPosition = targetPosition + offsetX + offsetY
        
        angleData.angle = actualAngleDegrees
        angleData.distance = distance
        
        return curvedPosition
    else
        angleData.angle = actualAngleDegrees
        angleData.distance = distance
        return targetPosition
    end
end

local function getSilentValidPlayers()
    local validPlayers = {}
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild('Humanoid')
            local rootPart = character:FindFirstChild('HumanoidRootPart')
            if humanoid and rootPart and humanoid.Health > 0 then
                local targetPart = character:FindFirstChild(Options.SilentHitPart.Value) or character:FindFirstChild('Head') or rootPart
                if targetPart then
                    table.insert(validPlayers, { player = player, character = character, targetPart = targetPart })
                end
            end
        end
    end
    
    if Toggles.IncludeNPCs.Value then
        local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
        if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
            local targetPart = dummy:FindFirstChild(Options.SilentHitPart.Value) or dummy:FindFirstChild('Head') or dummy.HumanoidRootPart
            if targetPart then
                table.insert(validPlayers, { player = nil, character = dummy, targetPart = targetPart })
            end
        end
    end
    
    return validPlayers
end

local function initializeSilentAim()
    if SilentAimInstance.fov then
        SilentAimInstance.fov:Remove()
    end
    if SilentAimInstance.tracer then
        SilentAimInstance.tracer:Remove()
    end
    if SilentAimInstance.connections then
        for _, connection in pairs(SilentAimInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    
    SilentAimInstance = {}
    
    silentFov = createSilentFovCircle()
    silentFov:SetRadius(Options.SilentFOV.Value)
    silentFov:SetColor(Color3.fromRGB(255, 255, 255))
    silentFov:SetVisible(Toggles.SilentFOVVisible.Value)
    silentFov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
    SilentAimInstance.fov = silentFov
    
    silentTracer = nil
    SilentAimInstance.tracer = nil
    
    SilentAimInstance.connections = {}
    
    local function getSilentKeyState()
        local mode = Options.SilentAimKey.Mode
        local key = Options.SilentAimKey.Value
        
        if mode == 'Always' then
            return true
        elseif mode == 'Hold' then
            if key == 'None' then return false end
            
            if key == 'MB1' or key == 'MB2' then
                return key == 'MB1' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                    or key == 'MB2' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
            else
                return UserInputService:IsKeyDown(Enum.KeyCode[key])
            end
        else
            return Options.SilentAimKey.Toggled or false
        end
    end
    
    local function findSilentTarget()
        local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
        if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
            local targetPart = nil
            if Toggles.SilentClosestMode.Value then
                targetPart = getClosestPart(dummy) or (dummy:FindFirstChild('Head') or dummy.HumanoidRootPart)
            else
                targetPart = dummy:FindFirstChild(Options.SilentHitPart.Value) or (dummy:FindFirstChild('Head') or dummy.HumanoidRootPart)
            end
            if targetPart then
                local fovValue = Options.SilentFOV and Options.SilentFOV.Value or 1000
                if isTargetInFOV(targetPart.Position, fovValue) then
                    return { character = dummy, targetPart = targetPart }
                end
            end
        end
        
        local validPlayers = getSilentValidPlayers()
        local closestDist = math.huge
        local bestTarget = nil
        
        for _, playerData in pairs(validPlayers) do
            local fovValue = Options.SilentFOV and Options.SilentFOV.Value or 1000
            if isTargetInFOV(playerData.targetPart.Position, fovValue) then
                local screenPos, onScreen = Camera:WorldToScreenPoint(playerData.targetPart.Position)
                if onScreen then
                    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
                    local screenPos2D = Vector2.new(screenPos.X, screenPos.Y)
                    local dist = (mousePos - screenPos2D).Magnitude
                    
                    if dist < closestDist then
                        closestDist = dist
                        bestTarget = playerData
                    end
                end
            end
        end
        
        return bestTarget
    end
    
    local lastPrintTime = 0
    local lastFOVRadius = Options.SilentFOV.Value
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if silentFov then
            silentFov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
            silentFov:SetVisible(Toggles.SilentFOVVisible.Value)
            
            local currentRadius = Options.SilentFOV.Value
            if currentRadius ~= lastFOVRadius then
                silentFov:SetRadius(currentRadius)
                lastFOVRadius = currentRadius
            end
        end
        
        if Toggles.VisualizeAntiCurve.Value and Toggles.SilentAimEnabled.Value then
            local currentTime = tick()
            if currentTime - lastPrintTime > 0.1 then
                local maxAngle = Options.MaxAngle.Value
                local currentAngle = angleData.angle
                local distance = angleData.distance
                local target = nil
                local targetPart = nil
                
                local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
                if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
                    target = dummy
                    targetPart = dummy.Head or dummy.HumanoidRootPart
                else
                    local validPlayers = getSilentValidPlayers()
                    local closestDist = math.huge
                    
                    for _, playerData in pairs(validPlayers) do
                        local screenPos, onScreen = Camera:WorldToScreenPoint(playerData.targetPart.Position)
                        
                        if onScreen then
                            local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                            if dist < closestDist then
                                closestDist = dist
                                target = playerData.character
                                targetPart = playerData.targetPart
                            end
                        end
                    end
                end
                
                if target and targetPart then
                    local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
                    local screenDist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                    
                    if onScreen and screenDist <= Options.SilentFOV.Value then
                        local crosshairRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
                        local targetDir = (targetPart.Position - Camera.CFrame.Position).Unit
                        local crosshairDir = crosshairRay.Direction
                        
                        local dot = crosshairDir:Dot(targetDir)
                        local angle = math.acos(math.clamp(dot, -1, 1))
                        local angleDeg = math.deg(angle)
                        
                        local charPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
                        local realDist = (targetPart.Position - charPos).Magnitude
                        
                        print(string.format("TARGETING - Angle: %.1f째 | Max: %.1f째 | Within limit: %s", angleDeg, maxAngle, tostring(angleDeg <= maxAngle)))
                    end
                end
                
                lastPrintTime = currentTime
            end
        end
    end)
    
    table.insert(SilentAimInstance.connections, renderConnection)
    
    local lastSilentKeyState = false
    
    local keyUpdateConnection = RunService.RenderStepped:Connect(function()
        if Options.TargetMode.Value == 'Target' then
            local keyActive = getSilentKeyState()
            
            if keyActive and not lastSilentKeyState then
                SilentLockedTarget = findSilentTarget()
            elseif not keyActive and lastSilentKeyState then
                SilentLockedTarget = nil
            end
            
            lastSilentKeyState = keyActive
        end
    end)
    
    table.insert(SilentAimInstance.connections, keyUpdateConnection)
    
    local oldIndex
    oldIndex = hookmetamethod(game, '__index', function(self, key)
        if self == Mouse and key:lower() == 'hit' and Toggles.SilentAimEnabled.Value then
            local target = nil
            local targetPart = nil
            
            if Options.TargetMode.Value == 'Auto' then
                target = findSilentTarget()
                if target then
                    targetPart = target.targetPart
                    target = target.character
                end
            elseif Options.TargetMode.Value == 'Target' then
                if SilentLockedTarget then
                    local fovValue = Options.SilentFOV and Options.SilentFOV.Value or 1000
                    if isTargetInFOV(SilentLockedTarget.targetPart.Position, fovValue) then
                            target = SilentLockedTarget.character
                            targetPart = SilentLockedTarget.targetPart
                            
                            if Toggles.SilentClosestMode.Value then
                                targetPart = getClosestPart(target)
                                if not targetPart then
                                    local rootPart = target:FindFirstChild('HumanoidRootPart')
                                    targetPart = target:FindFirstChild('Head') or rootPart
                                end
                            end
                        end
                    end
                end
            end
            
            if target and targetPart then
                local xPred = Options.SilentXPrediction.Value
                local yPred = Options.SilentYPrediction.Value
                local zPred = xPred
                
                local predicted = targetPart.CFrame + (targetPart.AssemblyLinearVelocity * Vector3.new(xPred, yPred, zPred))
                
                if Toggles.AntiCurveEnabled.Value then
                    local crosshairRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
                    local targetDir = (targetPart.Position - Camera.CFrame.Position).Unit
                    local crosshairDir = crosshairRay.Direction
                    
                    local dot = crosshairDir:Dot(targetDir)
                    local angle = math.acos(math.clamp(dot, -1, 1))
                    local angleDeg = math.deg(angle)
                    
                    local charPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
                    local dist = (targetPart.Position - charPos).Magnitude
                    
                    if Toggles.VisualizeAntiCurve.Value then
                        print(string.format("TARGETING - Angle: %.1f째 | Max: %.1f째 | Within limit: %s", angleDeg, Options.MaxAngle.Value, tostring(angleDeg <= Options.MaxAngle.Value)))
                    end
                    
                    if angleDeg <= Options.MaxAngle.Value then
                        if dist <= Options.DistanceThreshold.Value then
                            local curvedPos = applyAntiCurve(predicted.Position, Camera.CFrame.Position)
                            return CFrame.new(curvedPos)
                        else
                            return CFrame.new(predicted.Position)
                        end
                    end
                else
                    return CFrame.new(predicted.Position)
                end
            end
        end
        return oldIndex(self, key)
    end)
    
    SilentAimInstance.hook = oldIndex
end

Toggles.SilentAimEnabled:OnChanged(function()
    if Toggles.SilentAimEnabled.Value then
        initializeSilentAim()
    else
        if SilentAimInstance.fov then
            SilentAimInstance.fov:Remove()
        end
        if SilentAimInstance.tracer then
            SilentAimInstance.tracer:Remove()
        end
        if SilentAimInstance.connections then
            for _, connection in pairs(SilentAimInstance.connections) do
                if connection and connection.Disconnect then
                    connection:Disconnect()
                end
            end
        end
        if SilentAimInstance.hook then
            pcall(function()
                hookmetamethod(game, '__index', SilentAimInstance.hook)
            end)
        end
    end
end)

Library:SetWatermarkVisibility(true)
Library:SetWatermark("z2v9's menu | " .. gameName)

Library:OnUnload(function()
    LockedTarget = nil
    if AimAssistInstance and AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance and AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    if AimAssistInstance and AimAssistInstance.hook then
        restoremetamethod(game, '__index', AimAssistInstance.hook)
    end
    if SilentAimInstance and SilentAimInstance.fov then
        SilentAimInstance.fov:Remove()
    end
    if SilentAimInstance and SilentAimInstance.tracer then
        SilentAimInstance.tracer:Remove()
    end
    if SilentAimInstance and SilentAimInstance.connections then
        for _, connection in pairs(SilentAimInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    if SilentAimInstance and SilentAimInstance.hook then
        pcall(function()
            hookmetamethod(game, '__index', SilentAimInstance.hook)
        end)
    end
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind', 'CacheInterval' })
ThemeManager:SetFolder('AimAssistScript')
SaveManager:SetFolder('AimAssistScript/game')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()
