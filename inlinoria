local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Aim Assist',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Aim Assist'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aim Assist')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Silent Aim')
local LeftGroupBox2 = Tabs.Main:AddLeftGroupbox('Aim Assist Prediction')
local LeftGroupBox3 = Tabs.Main:AddLeftGroupbox('Aim Assist Smoothing')

local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local CoreGui = game:GetService('CoreGui')

local AimAssistInstance = {}
local fov = nil
local LockedTarget = nil

LeftGroupBox:AddToggle('AimAssistEnabled', {
    Text = 'Enabled',
    Default = false,
    Tooltip = 'Enable/disable aim assist functionality'
})

Toggles.AimAssistEnabled:AddKeyPicker('AimKey', {
    Default = 'C',
    Mode = 'Toggle',
    Text = 'Aim Assist',
    NoUI = false,
})

LeftGroupBox:AddSlider('FOV', {
    Text = 'FOV',
    Default = 500,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Tooltip = 'Field of view for target detection'
})

LeftGroupBox:AddToggle('FOVVisible', {
    Text = 'FOV Visible',
    Default = false,
    Tooltip = 'Show FOV circle'
})

LeftGroupBox:AddDropdown('HitPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 1,
    Text = 'Hit Part',
    Tooltip = 'Target body part'
})

LeftGroupBox:AddToggle('ClosestMode', {
    Text = 'Closest Mode',
    Default = false,
    Tooltip = 'Target closest body part instead of specific part'
})

LeftGroupBox:AddToggle('IncludeNPCs', {
    Text = 'Include NPCs',
    Default = true,
    Tooltip = 'Target NPCs/bots (may reduce performance)'
})

LeftGroupBox:AddToggle('WallCheck', {
    Text = 'Wall Check',
    Default = false,
    Tooltip = 'Only target visible players, stop aiming when target goes behind wall'
})

RightGroupBox:AddToggle('SilentAimEnabled', {
    Text = 'Enabled',
    Default = false,
    Tooltip = 'Enable/disable silent aim functionality'
}):AddKeyPicker('SilentAimKey', {
    Default = 'Q',
    Mode = 'Toggle',
    Text = 'Silent Aim',
    NoUI = false,
})

RightGroupBox:AddDropdown('TargetMode', {
    Values = {'Auto', 'Target'},
    Default = 1,
    Text = 'Target Mode',
    Tooltip = 'Auto = targets based on mouse/FOV | Target = requires key press'
})

RightGroupBox:AddSlider('SilentFOV', {
    Text = 'FOV',
    Default = 1000,
    Min = 100,
    Max = 2000,
    Rounding = 0,
    Tooltip = 'Field of view for silent aim'
})

RightGroupBox:AddToggle('SilentFOVVisible', {
    Text = 'FOV Visible',
    Default = false,
    Tooltip = 'Show silent aim FOV circle'
})

RightGroupBox:AddSlider('SilentXPrediction', {
    Text = 'X Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'X-axis prediction value'
})

RightGroupBox:AddSlider('SilentYPrediction', {
    Text = 'Y Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'Y-axis prediction value'
})

RightGroupBox:AddDropdown('SilentHitPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 1,
    Text = 'Hit Part',
    Tooltip = 'Target body part for silent aim'
})

RightGroupBox:AddToggle('SilentClosestMode', {
    Text = 'Closest Mode',
    Default = false,
    Tooltip = 'Target closest body part instead of specific part'
})

RightGroupBox:AddToggle('AntiCurveEnabled', {
    Text = 'Anti Curve',
    Default = false,
    Tooltip = 'Enable anti-curve / resolver functionality'
})

RightGroupBox:AddSlider('MaxAngle', {
    Text = 'Max Angle',
    Default = 7.67,
    Min = 0,
    Max = 45,
    Rounding = 2,
    Tooltip = 'Maximum angle for anti-curve'
})

RightGroupBox:AddSlider('DistanceThreshold', {
    Text = 'Distance Threshold',
    Default = 50,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Tooltip = 'Distance threshold for anti-curve activation'
})

RightGroupBox:AddToggle('VisualizeAntiCurve', {
    Text = 'Visualize Anti Curve',
    Default = false,
    Tooltip = 'Show anti-curve debug information'
})

LeftGroupBox2:AddSlider('XPrediction', {
    Text = 'X Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'X-axis bullet prediction value'
})

LeftGroupBox2:AddSlider('YPrediction', {
    Text = 'Y Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.75,
    Rounding = 4,
    Tooltip = 'Y-axis bullet prediction value'
})

-- removed ZPrediction

LeftGroupBox3:AddSlider('XSmoothing', {
    Text = 'X Smoothing',
    Default = 0.5,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Tooltip = '1.0 = sharpest, 0.01 = smoothest'
})

LeftGroupBox3:AddSlider('YSmoothing', {
    Text = 'Y Smoothing',
    Default = 0.5,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Tooltip = '1.0 = sharpest, 0.01 = smoothest'
})

-- removed ZSmoothing

-- removed easing controls

-- removed humanizer controls

-- removed humanizer samples

local function resolveGuiParent()
    local ok, hui = pcall(function()
        return gethui and gethui()
    end)
    if ok and hui then return hui end
    local pg = LocalPlayer:FindFirstChildWhichIsA('PlayerGui')
    if pg then return pg end
    return CoreGui
end

local function createFovCircle()
    local wrapper = {}
    if Drawing then
        local circle = Drawing.new('Circle')
        circle.Thickness = 1
        circle.Filled = false
        circle.Transparency = 1
        function wrapper:SetRadius(r)
            circle.Radius = r
        end
        function wrapper:SetPosition(v2)
            circle.Position = v2
        end
        function wrapper:SetVisible(v)
            circle.Visible = v
        end
        function wrapper:SetColor(c)
            circle.Color = c
        end
        function wrapper:Remove()
            if circle then circle:Remove() end
        end
        return wrapper
    else
        local gui = Instance.new('ScreenGui')
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false
        gui.Name = 'AimAssistFOV'
        gui.Parent = resolveGuiParent()
        local frame = Instance.new('Frame')
        frame.BackgroundTransparency = 1
        frame.AnchorPoint = Vector2.new(0.5, 0.5)
        frame.Size = UDim2.fromOffset(0, 0)
        frame.Position = UDim2.fromOffset(0, 0)
        frame.Parent = gui
        local stroke = Instance.new('UIStroke')
        stroke.Thickness = 1
        stroke.Parent = frame
        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = frame
        function wrapper:SetRadius(r)
            frame.Size = UDim2.fromOffset(r * 2, r * 2)
        end
        function wrapper:SetPosition(v2)
            frame.Position = UDim2.fromOffset(v2.X, v2.Y)
        end
        function wrapper:SetVisible(v)
            frame.Visible = v
        end
        function wrapper:SetColor(c)
            stroke.Color = c
        end
        function wrapper:Remove()
            if gui then gui:Destroy() end
        end
        return wrapper
    end
end

local function getClosestPart(character)
    if not character then return nil end
    
    local parts = {}
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            table.insert(parts, part)
        end
    end
    
    local closestPart = nil
    local closestDist = math.huge
    
    for _, part in pairs(parts) do
        local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position)
        if onScreen then
            local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPart = part
            end
        end
    end
    
    return closestPart
end

local function getClosestPartToCrosshair(character)
    if not character then return nil end
    
    local parts = {}
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            table.insert(parts, part)
        end
    end
    
    local closestPart = nil
    local closestAngle = math.huge
    local camPos = Camera.CFrame.Position
    local camLook = Camera.CFrame.LookVector
    
    for _, part in pairs(parts) do
        local direction = (part.Position - camPos).Unit
        local dot = camLook:Dot(direction)
        local angle = math.acos(math.clamp(dot, -1, 1))
        
        if angle < closestAngle then
            closestAngle = angle
            closestPart = part
        end
    end
    
    return closestPart
end

local function isVisible(targetPart, targetCharacter)
    if not Toggles.WallCheck.Value then return true end
    if not targetPart or not targetCharacter then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local distance = direction.Magnitude
    direction = direction.Unit
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetCharacter}
    rayParams.IgnoreWater = true
    
    local rayResult = workspace:Raycast(origin, direction * distance, rayParams)
    
    if not rayResult then
        return true
    end
    
    if rayResult.Instance then
        local hitParent = rayResult.Instance.Parent
        if hitParent == targetCharacter or rayResult.Instance == targetPart then
            return true
        end
        
        if hitParent and hitParent:IsA('Accessory') then
            local accessoryParent = hitParent.Parent
            if accessoryParent == targetCharacter then
                return true
            end
        end
    end
    
    return false
end

-- removed humanizer logic

local function getValidPlayers()
    local validPlayers = {}
    local hitPartValue = Options.HitPart.Value
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild('Humanoid')
            local rootPart = character:FindFirstChild('HumanoidRootPart')
            if humanoid and rootPart and humanoid.Health > 0 then
                local targetPart = character:FindFirstChild(hitPartValue) or character:FindFirstChild('Head') or rootPart
                if targetPart then
                    table.insert(validPlayers, { player = player, character = character, targetPart = targetPart })
                end
            end
        end
    end
    
    if Toggles.IncludeNPCs.Value then
        local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
        if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
            local targetPart = dummy:FindFirstChild(hitPartValue) or dummy:FindFirstChild('Head') or dummy.HumanoidRootPart
            if targetPart then
                table.insert(validPlayers, { player = nil, character = dummy, targetPart = targetPart })
            end
        end
    end
    
    return validPlayers
end

local function initializeAimAssist()
    if AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    
    AimAssistInstance = {}
    
    fov = createFovCircle()
    fov:SetRadius(Options.FOV.Value)
    fov:SetColor(Color3.fromRGB(0, 255, 0))
    fov:SetVisible(Toggles.FOVVisible.Value)
    fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
    AimAssistInstance.fov = fov
    
    AimAssistInstance.connections = {}
    
    local lastFOVRadius = Options.FOV.Value
    local lastFOVVisible = Toggles.FOVVisible.Value
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if fov then
            fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
            local currentVisible = Toggles.FOVVisible.Value
            local currentRadius = Options.FOV.Value
            if currentVisible ~= lastFOVVisible then
                fov:SetVisible(currentVisible)
                lastFOVVisible = currentVisible
            end
            if currentRadius ~= lastFOVRadius then
                fov:SetRadius(currentRadius)
                lastFOVRadius = currentRadius
            end
        end
    end)
    
    table.insert(AimAssistInstance.connections, renderConnection)
    
    local function findClosestTarget()
        local validPlayers = getValidPlayers()
        if #validPlayers == 0 then return nil end
        
        local closestDist = math.huge
        local bestTarget = nil
        local mousePos = Vector2.new(Mouse.X, Mouse.Y)
        local fovValue = Options.FOV.Value
        
        for _, playerData in pairs(validPlayers) do
            local targetPart = playerData.targetPart
            local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
            if onScreen then
                local dist = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < closestDist and dist <= fovValue then
                    closestDist = dist
                    bestTarget = playerData
                end
            end
        end
        
        return bestTarget
    end
    
    local function isTargetValid(target)
        if not target or not target.character or not target.targetPart then return false end
        if not target.character.Parent then return false end
        
        local humanoid = target.character:FindFirstChild('Humanoid')
        if not humanoid or humanoid.Health <= 0 then return false end
        
        if not isVisible(target.targetPart, target.character) then return false end
        
        return true
    end
    
    local function getKeyState()
        local mode = Options.AimKey.Mode
        local key = Options.AimKey.Value
        
        if mode == 'Always' then
            return true
        elseif mode == 'Hold' then
            if key == 'None' then return false end
            
            if key == 'MB1' or key == 'MB2' then
                return key == 'MB1' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                    or key == 'MB2' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
            else
                return UserInputService:IsKeyDown(Enum.KeyCode[key])
            end
        else
            return Options.AimKey.Toggled or false
        end
    end
    
    local lastActiveState = false
    
    local aimConnection = RunService.RenderStepped:Connect(function(dt)
        local keyActive = getKeyState()
        
        if keyActive and not lastActiveState then
            LockedTarget = findClosestTarget()
            if fov then
                fov:SetColor(Color3.fromRGB(255, 0, 0))
            end
        elseif not keyActive and lastActiveState then
            LockedTarget = nil
            if fov then
                fov:SetColor(Color3.fromRGB(0, 255, 0))
            end
        end
        
        lastActiveState = keyActive
        
        if not keyActive then return end
        if not LockedTarget then return end
        
        if not isTargetValid(LockedTarget) then
            LockedTarget = findClosestTarget()
            if not LockedTarget then
                if fov then
                    fov:SetColor(Color3.fromRGB(0, 255, 0))
                end
                return
            end
        end
        
        local targetChar = LockedTarget.character
        if not targetChar then return end
        
        local targetPart = LockedTarget.targetPart
        
        if Toggles.ClosestMode.Value then
            targetPart = getClosestPartToCrosshair(targetChar)
            if not targetPart then
                local rootPart = targetChar:FindFirstChild('HumanoidRootPart')
                targetPart = targetChar:FindFirstChild('Head') or rootPart
            end
        end
        
        if not targetPart then return end
        
        local xPred = Options.XPrediction.Value
        local yPred = Options.YPrediction.Value
        local zPred = xPred
        
        local velocity = targetPart.AssemblyLinearVelocity
        local predictedPos = targetPart.Position + (velocity * Vector3.new(xPred, yPred, zPred))
        
        local currentCam = Camera.CFrame
        local targetCFrame = CFrame.new(currentCam.Position, predictedPos)
        
        local xSmooth = Options.XSmoothing.Value
        local ySmooth = Options.YSmoothing.Value
        local avgSmooth = (xSmooth + ySmooth) * 0.5
        
        local smoothness = math.clamp(avgSmooth, 0, 1)
        
        Camera.CFrame = currentCam:Lerp(targetCFrame, smoothness)
    end)
    
    table.insert(AimAssistInstance.connections, aimConnection)
    
end

Toggles.AimAssistEnabled:OnChanged(function()
    if Toggles.AimAssistEnabled.Value then
        LockedTarget = nil
        initializeAimAssist()
    else
        LockedTarget = nil
        if AimAssistInstance.fov then
            AimAssistInstance.fov:Remove()
        end
        if AimAssistInstance.connections then
            for _, connection in pairs(AimAssistInstance.connections) do
                if connection and connection.Disconnect then
                    connection:Disconnect()
                end
            end
        end
        if AimAssistInstance.hook then
            restoremetamethod(game, '__index', AimAssistInstance.hook)
        end
    end
end)

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Aim Assist | LinoriaLib')

Library:OnUnload(function()
    LockedTarget = nil
    if AimAssistInstance and AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance and AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    if AimAssistInstance and AimAssistInstance.hook then
        restoremetamethod(game, '__index', AimAssistInstance.hook)
    end
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind', 'CacheInterval' })
ThemeManager:SetFolder('AimAssistScript')
SaveManager:SetFolder('AimAssistScript/game')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()


-- loadstring(game:HttpGet('https://raw.githubusercontent.com/percxs/botsilent/refs/heads/main/inlinoria'))()
    
