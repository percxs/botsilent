local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Aim Assist',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Aim Assist'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Main Settings')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Prediction')
local SmoothingGroupBox = Tabs.Main:AddLeftGroupbox('Smoothing')

local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local CoreGui = game:GetService('CoreGui')

local AimAssistInstance = {}
local fov = nil
local AimAssistActive = false
local LockedTarget = nil

LeftGroupBox:AddToggle('AimAssistEnabled', {
    Text = 'Aim Assist',
    Default = false,
    Tooltip = 'Enable/disable aim assist functionality'
})

LeftGroupBox:AddSlider('FOV', {
    Text = 'FOV',
    Default = 500,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Tooltip = 'Field of view for target detection'
})

LeftGroupBox:AddDropdown('HitPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 1,
    Text = 'Hit Part',
    Tooltip = 'Target body part'
})

LeftGroupBox:AddToggle('ClosestMode', {
    Text = 'Closest Mode',
    Default = false,
    Tooltip = 'Target closest body part instead of specific part'
})

LeftGroupBox:AddToggle('FOVVisible', {
    Text = 'FOV Visible',
    Default = false,
    Tooltip = 'Show FOV circle'
})

LeftGroupBox:AddToggle('IncludeNPCs', {
    Text = 'Include NPCs',
    Default = true,
    Tooltip = 'Target NPCs/bots (may reduce performance)'
})

LeftGroupBox:AddToggle('WallCheck', {
    Text = 'Wall Check',
    Default = false,
    Tooltip = 'Only target visible players, stop aiming when target goes behind wall'
})

LeftGroupBox:AddLabel('Aim Key'):AddKeyPicker('AimKey', {
    Default = 'C',
    Mode = 'Toggle',
    Text = 'Aim Assist Keybind',
    NoUI = false,
})

RightGroupBox:AddSlider('XPrediction', {
    Text = 'X Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.1,
    Rounding = 4,
    Tooltip = 'X-axis bullet prediction value'
})

RightGroupBox:AddSlider('YPrediction', {
    Text = 'Y Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.1,
    Rounding = 4,
    Tooltip = 'Y-axis bullet prediction value (for air targets)'
})

-- removed ZPrediction

SmoothingGroupBox:AddSlider('XSmoothing', {
    Text = 'X Smoothing',
    Default = 1,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Tooltip = 'X-axis smoothing strength'
})

SmoothingGroupBox:AddSlider('YSmoothing', {
    Text = 'Y Smoothing',
    Default = 1,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Tooltip = 'Y-axis smoothing strength (for air targets)'
})

-- removed ZSmoothing

-- removed easing controls

-- removed humanizer controls

-- removed humanizer samples

local function resolveGuiParent()
    local ok, hui = pcall(function()
        return gethui and gethui()
    end)
    if ok and hui then return hui end
    local pg = LocalPlayer:FindFirstChildWhichIsA('PlayerGui')
    if pg then return pg end
    return CoreGui
end

local function createFovCircle()
    local wrapper = {}
    if Drawing then
        local circle = Drawing.new('Circle')
        circle.Thickness = 1
        circle.Filled = false
        circle.Transparency = 1
        function wrapper:SetRadius(r)
            circle.Radius = r
        end
        function wrapper:SetPosition(v2)
            circle.Position = v2
        end
        function wrapper:SetVisible(v)
            circle.Visible = v
        end
        function wrapper:SetColor(c)
            circle.Color = c
        end
        function wrapper:Remove()
            if circle then circle:Remove() end
        end
        return wrapper
    else
        local gui = Instance.new('ScreenGui')
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false
        gui.Name = 'AimAssistFOV'
        gui.Parent = resolveGuiParent()
        local frame = Instance.new('Frame')
        frame.BackgroundTransparency = 1
        frame.AnchorPoint = Vector2.new(0.5, 0.5)
        frame.Size = UDim2.fromOffset(0, 0)
        frame.Position = UDim2.fromOffset(0, 0)
        frame.Parent = gui
        local stroke = Instance.new('UIStroke')
        stroke.Thickness = 1
        stroke.Parent = frame
        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = frame
        function wrapper:SetRadius(r)
            frame.Size = UDim2.fromOffset(r * 2, r * 2)
        end
        function wrapper:SetPosition(v2)
            frame.Position = UDim2.fromOffset(v2.X, v2.Y)
        end
        function wrapper:SetVisible(v)
            frame.Visible = v
        end
        function wrapper:SetColor(c)
            stroke.Color = c
        end
        function wrapper:Remove()
            if gui then gui:Destroy() end
        end
        return wrapper
    end
end

local function getClosestPart(character)
    if not character then return nil end
    
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    local closestPart = nil
    local closestDist = math.huge
    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position)
            if onScreen then
                local dist = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestPart = part
                end
            end
        end
    end
    
    return closestPart
end

local function isInAir(character)
    if not character or not character:FindFirstChild('HumanoidRootPart') then return false end
    local rootPart = character.HumanoidRootPart
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.FilterDescendantsInstances = {character, LocalPlayer.Character}
    local raycast = workspace:Raycast(rootPart.Position, Vector3.new(0, -10, 0), rayParams)
    return raycast == nil
end

local function isVisible(targetPart, targetCharacter)
    if not Toggles.WallCheck.Value then return true end
    if not targetPart or not targetCharacter then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local distance = direction.Magnitude
    direction = direction.Unit
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetCharacter}
    rayParams.IgnoreWater = true
    
    local rayResult = workspace:Raycast(origin, direction * distance, rayParams)
    
    if not rayResult then
        return true
    end
    
    if rayResult.Instance then
        local hitParent = rayResult.Instance.Parent
        if hitParent == targetCharacter or rayResult.Instance == targetPart then
            return true
        end
        
        if hitParent and hitParent:IsA('Accessory') then
            local accessoryParent = hitParent.Parent
            if accessoryParent == targetCharacter then
                return true
            end
        end
    end
    
    return false
end

-- removed humanizer logic

local function getValidPlayers()
    local validPlayers = {}
    local closestMode = Toggles.ClosestMode.Value
    local hitPartValue = Options.HitPart.Value
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild('Humanoid')
            local rootPart = character:FindFirstChild('HumanoidRootPart')
            if humanoid and rootPart and humanoid.Health > 0 then
                local targetPart = nil
                if closestMode then
                    targetPart = getClosestPart(character) or (character:FindFirstChild('Head') or rootPart)
                else
                    targetPart = character:FindFirstChild(hitPartValue) or (character:FindFirstChild('Head') or rootPart)
                end
                if targetPart and isVisible(targetPart, character) then
                    table.insert(validPlayers, { player = player, character = character, targetPart = targetPart })
                end
            end
        end
    end
    
    if Toggles.IncludeNPCs.Value then
        for _, inst in ipairs(workspace:GetChildren()) do
            if inst:IsA('Model') and inst ~= LocalPlayer.Character then
                local humanoid = inst:FindFirstChildOfClass('Humanoid')
                local rootPart = inst:FindFirstChild('HumanoidRootPart')
                if humanoid and rootPart and humanoid.Health > 0 then
                    local isPlayer = false
                    for _, player in pairs(Players:GetPlayers()) do
                        if player.Character == inst then
                            isPlayer = true
                            break
                        end
                    end
                    if not isPlayer then
                        local targetPart = nil
                        if closestMode then
                            targetPart = getClosestPart(inst) or (inst:FindFirstChild('Head') or rootPart)
                        else
                            targetPart = inst:FindFirstChild(hitPartValue) or (inst:FindFirstChild('Head') or rootPart)
                        end
                        if targetPart and isVisible(targetPart, inst) then
                            table.insert(validPlayers, { player = nil, character = inst, targetPart = targetPart })
                        end
                    end
                end
            end
        end
    end
    
    return validPlayers
end

local function initializeAimAssist()
    if AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    
    AimAssistInstance = {}
    
    fov = createFovCircle()
    fov:SetRadius(Options.FOV.Value)
    fov:SetColor(Color3.fromRGB(0, 255, 0))
    fov:SetVisible(Toggles.FOVVisible.Value)
    fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
    AimAssistInstance.fov = fov
    
    AimAssistInstance.connections = {}
    
    local lastFOVRadius = Options.FOV.Value
    local lastFOVVisible = Toggles.FOVVisible.Value
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if fov then
            fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
            local currentVisible = Toggles.FOVVisible.Value
            local currentRadius = Options.FOV.Value
            if currentVisible ~= lastFOVVisible then
                fov:SetVisible(currentVisible)
                lastFOVVisible = currentVisible
            end
            if currentRadius ~= lastFOVRadius then
                fov:SetRadius(currentRadius)
                lastFOVRadius = currentRadius
            end
        end
    end)
    
    table.insert(AimAssistInstance.connections, renderConnection)
    
    local function findClosestTarget()
        local validPlayers = getValidPlayers()
        if #validPlayers == 0 then return nil end
        
        local closestDist = math.huge
        local bestTarget = nil
        local mousePos = Vector2.new(Mouse.X, Mouse.Y)
        local fovValue = Options.FOV.Value
        
        for _, playerData in pairs(validPlayers) do
            local targetPart = playerData.targetPart
            local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
            if onScreen then
                local dist = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < closestDist and dist <= fovValue then
                    closestDist = dist
                    bestTarget = playerData
                end
            end
        end
        
        return bestTarget
    end
    
    local function isTargetValid(target)
        if not target or not target.character or not target.targetPart then return false end
        if not target.character.Parent then return false end
        
        local humanoid = target.character:FindFirstChild('Humanoid')
        if not humanoid or humanoid.Health <= 0 then return false end
        
        if not isVisible(target.targetPart, target.character) then return false end
        
        return true
    end
    
    local keyConnection = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        
        local aimKeyValue = Options.AimKey.Value
        if not aimKeyValue then return end
        
        if input.KeyCode.Name == aimKeyValue or input.KeyCode == Enum.KeyCode[aimKeyValue] then
            if not AimAssistActive then
                LockedTarget = findClosestTarget()
                if LockedTarget then
                    AimAssistActive = true
                    if fov then
                        fov:SetColor(Color3.fromRGB(255, 0, 0))
                    end
                end
            else
                AimAssistActive = false
                LockedTarget = nil
                if fov then
                    fov:SetColor(Color3.fromRGB(0, 255, 0))
                end
            end
        end
    end)
    
    table.insert(AimAssistInstance.connections, keyConnection)
    
    local aimConnection = RunService.RenderStepped:Connect(function(dt)
        if not AimAssistActive then return end
        
        if not isTargetValid(LockedTarget) then
            LockedTarget = findClosestTarget()
            if not LockedTarget then
                AimAssistActive = false
                if fov then
                    fov:SetColor(Color3.fromRGB(0, 255, 0))
                end
                return
            end
        end
        
        local targetPart = LockedTarget.targetPart
        local targetChar = LockedTarget.character
        
        if not targetPart or not targetChar then
            return
        end
        
        local inAir = isInAir(targetChar)
        local xPred = Options.XPrediction.Value
        local yPred = inAir and Options.YPrediction.Value or 0
        
        local velocity = targetPart.AssemblyLinearVelocity
        local predictedPos = targetPart.Position + Vector3.new(velocity.X * xPred, velocity.Y * yPred, 0)
        
        local currentCam = Camera.CFrame
        local targetCFrame = CFrame.new(currentCam.Position, predictedPos)
        
        local xSmooth = Options.XSmoothing.Value
        local ySmooth = Options.YSmoothing.Value
        local avgSmooth = (xSmooth + ySmooth) * 0.5
        
        local smoothness = math.clamp(dt * (10 / math.max(0.1, avgSmooth)), 0, 1)
        
        Camera.CFrame = currentCam:Lerp(targetCFrame, smoothness)
    end)
    
    table.insert(AimAssistInstance.connections, aimConnection)
    
end

Toggles.AimAssistEnabled:OnChanged(function()
    if Toggles.AimAssistEnabled.Value then
        AimAssistActive = false
        LockedTarget = nil
        initializeAimAssist()
    else
        AimAssistActive = false
        LockedTarget = nil
        if AimAssistInstance.fov then
            AimAssistInstance.fov:Remove()
        end
        if AimAssistInstance.connections then
            for _, connection in pairs(AimAssistInstance.connections) do
                if connection and connection.Disconnect then
                    connection:Disconnect()
                end
            end
        end
        if AimAssistInstance.hook then
            restoremetamethod(game, '__index', AimAssistInstance.hook)
        end
    end
end)

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Aim Assist | LinoriaLib')

Library:OnUnload(function()
    AimAssistActive = false
    LockedTarget = nil
    if AimAssistInstance and AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance and AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    if AimAssistInstance and AimAssistInstance.hook then
        restoremetamethod(game, '__index', AimAssistInstance.hook)
    end
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind', 'CacheInterval' })
ThemeManager:SetFolder('AimAssistScript')
SaveManager:SetFolder('AimAssistScript/game')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()


-- loadstring(game:HttpGet('https://raw.githubusercontent.com/percxs/botsilent/refs/heads/main/inlinoria'))()
    
