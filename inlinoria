local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Aim Assist',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Aim Assist'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Main Settings')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Prediction')
local SmoothingGroupBox = Tabs.Main:AddLeftGroupbox('Smoothing')

local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local CoreGui = game:GetService('CoreGui')

local AimAssistInstance = {}
local AimAssistEnabled = false
local fov = nil

LeftGroupBox:AddToggle('AimAssistEnabled', {
    Text = 'Aim Assist',
    Default = false,
    Tooltip = 'Enable/disable aim assist functionality'
})

LeftGroupBox:AddSlider('FOV', {
    Text = 'FOV',
    Default = 500,
    Min = 100,
    Max = 1000,
    Rounding = 0,
    Tooltip = 'Field of view for target detection'
})

LeftGroupBox:AddDropdown('HitPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 1,
    Text = 'Hit Part',
    Tooltip = 'Target body part'
})

LeftGroupBox:AddToggle('ClosestMode', {
    Text = 'Closest Mode',
    Default = false,
    Tooltip = 'Target closest body part instead of specific part'
})

LeftGroupBox:AddToggle('FOVVisible', {
    Text = 'FOV Visible',
    Default = false,
    Tooltip = 'Show FOV circle'
})

LeftGroupBox:AddLabel('Aim Key'):AddKeyPicker('AimKey', {
    Default = 'C',
    Mode = 'Toggle',
    Text = 'Aim Assist Keybind',
    NoUI = false,
})

RightGroupBox:AddSlider('XPrediction', {
    Text = 'X Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.1,
    Rounding = 4,
    Tooltip = 'X-axis bullet prediction value'
})

RightGroupBox:AddSlider('YPrediction', {
    Text = 'Y Prediction',
    Default = 0.0223,
    Min = 0,
    Max = 0.1,
    Rounding = 4,
    Tooltip = 'Y-axis bullet prediction value (for air targets)'
})

-- removed ZPrediction

SmoothingGroupBox:AddSlider('XSmoothing', {
    Text = 'X Smoothing',
    Default = 1,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Tooltip = 'X-axis smoothing strength'
})

SmoothingGroupBox:AddSlider('YSmoothing', {
    Text = 'Y Smoothing',
    Default = 1,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Tooltip = 'Y-axis smoothing strength (for air targets)'
})

-- removed ZSmoothing

-- removed easing controls

-- removed humanizer controls

-- removed humanizer samples

local function resolveGuiParent()
    local ok, hui = pcall(function()
        return gethui and gethui()
    end)
    if ok and hui then return hui end
    local pg = LocalPlayer:FindFirstChildWhichIsA('PlayerGui')
    if pg then return pg end
    return CoreGui
end

local function createFovCircle()
    local wrapper = {}
    if Drawing then
        local circle = Drawing.new('Circle')
        circle.Thickness = 1
        circle.Filled = false
        circle.Transparency = 1
        function wrapper:SetRadius(r)
            circle.Radius = r
        end
        function wrapper:SetPosition(v2)
            circle.Position = v2
        end
        function wrapper:SetVisible(v)
            circle.Visible = v
        end
        function wrapper:SetColor(c)
            circle.Color = c
        end
        function wrapper:Remove()
            if circle then circle:Remove() end
        end
        return wrapper
    else
        local gui = Instance.new('ScreenGui')
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false
        gui.Name = 'AimAssistFOV'
        gui.Parent = resolveGuiParent()
        local frame = Instance.new('Frame')
        frame.BackgroundTransparency = 1
        frame.AnchorPoint = Vector2.new(0.5, 0.5)
        frame.Size = UDim2.fromOffset(0, 0)
        frame.Position = UDim2.fromOffset(0, 0)
        frame.Parent = gui
        local stroke = Instance.new('UIStroke')
        stroke.Thickness = 1
        stroke.Parent = frame
        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = frame
        function wrapper:SetRadius(r)
            frame.Size = UDim2.fromOffset(r * 2, r * 2)
        end
        function wrapper:SetPosition(v2)
            frame.Position = UDim2.fromOffset(v2.X, v2.Y)
        end
        function wrapper:SetVisible(v)
            frame.Visible = v
        end
        function wrapper:SetColor(c)
            stroke.Color = c
        end
        function wrapper:Remove()
            if gui then gui:Destroy() end
        end
        return wrapper
    end
end

local function getClosestPart(character)
    if not character then return nil end
    
    local parts = {}
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            table.insert(parts, part)
        end
    end
    
    local closestPart = nil
    local closestDist = math.huge
    
    for _, part in pairs(parts) do
        local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position)
        if onScreen then
            local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPart = part
            end
        end
    end
    
    return closestPart
end

local function isInAir(character)
    if not character or not character:FindFirstChild('HumanoidRootPart') then return false end
    local rootPart = character.HumanoidRootPart
    local raycast = workspace:Raycast(rootPart.Position, Vector3.new(0, -10, 0))
    return raycast == nil
end

-- removed humanizer logic

local function getValidPlayers()
    local validPlayers = {}
    local seen = {}
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild('Humanoid')
            local rootPart = character:FindFirstChild('HumanoidRootPart')
            if humanoid and rootPart and humanoid.Health > 0 then
                local targetPart = nil
                if Toggles.ClosestMode.Value then
                    targetPart = getClosestPart(character) or (character:FindFirstChild('Head') or rootPart)
                else
                    targetPart = character:FindFirstChild(Options.HitPart.Value) or (character:FindFirstChild('Head') or rootPart)
                end
                if targetPart then
                    table.insert(validPlayers, { player = player, character = character, targetPart = targetPart })
                    seen[character] = true
                end
            end
        end
    end
    
    for _, inst in ipairs(workspace:GetDescendants()) do
        if inst:IsA('Model') and not seen[inst] then
            local humanoid = inst:FindFirstChildOfClass('Humanoid')
            local rootPart = inst:FindFirstChild('HumanoidRootPart')
            if humanoid and rootPart and humanoid.Health > 0 then
                if not (LocalPlayer.Character and inst == LocalPlayer.Character) then
                    local targetPart = nil
                    if Toggles.ClosestMode.Value then
                        targetPart = getClosestPart(inst) or (inst:FindFirstChild('Head') or rootPart)
                    else
                        targetPart = inst:FindFirstChild(Options.HitPart.Value) or (inst:FindFirstChild('Head') or rootPart)
                    end
                    if targetPart then
                        table.insert(validPlayers, { player = nil, character = inst, targetPart = targetPart })
                        seen[inst] = true
                    end
                end
            end
        end
    end
    
    return validPlayers
end

local function initializeAimAssist()
    if AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    
    AimAssistInstance = {}
    
    fov = createFovCircle()
    fov:SetRadius(Options.FOV.Value)
    fov:SetColor(Color3.fromRGB(255, 0, 0))
    fov:SetVisible(Toggles.FOVVisible.Value)
    fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
    AimAssistInstance.fov = fov
    
    AimAssistInstance.connections = {}
    
    local renderConnection = RunService.RenderStepped:Connect(function()
        if fov then
            fov:SetPosition(Vector2.new(Mouse.X, Mouse.Y))
            fov:SetVisible(Toggles.FOVVisible.Value)
            fov:SetRadius(Options.FOV.Value)
        end
    end)
    
    table.insert(AimAssistInstance.connections, renderConnection)
    
    local keyConnection = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode[Options.AimKey.Value] then
            AimAssistEnabled = not AimAssistEnabled
            if fov then
                fov:SetColor(AimAssistEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0))
            end
        end
    end)
    
    table.insert(AimAssistInstance.connections, keyConnection)
    
    local AimHold = false
    local inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 then
            AimHold = true
        end
    end)
    
    local inputEndedConnection = UserInputService.InputEnded:Connect(function(input, gp)
        if gp then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 then
            AimHold = false
        end
    end)
    
    table.insert(AimAssistInstance.connections, inputBeganConnection)
    table.insert(AimAssistInstance.connections, inputEndedConnection)

    local aimConnection = RunService.Heartbeat:Connect(function(dt)
        if not (AimAssistEnabled or AimHold) then return end
        
        local validPlayers = getValidPlayers()
        local closestDist = math.huge
        local bestPart = nil
        local bestCharacter = nil
        
        for _, playerData in pairs(validPlayers) do
            local screenPos, onScreen = Camera:WorldToScreenPoint(playerData.targetPart.Position)
            if onScreen then
                local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                if dist < closestDist and dist <= Options.FOV.Value then
                    closestDist = dist
                    bestPart = playerData.targetPart
                    bestCharacter = playerData.character
                end
            end
        end
        
        if bestPart then
            if Camera.CameraType ~= Enum.CameraType.Scriptable then
                Camera.CameraType = Enum.CameraType.Scriptable
            end
            local inAir = isInAir(bestCharacter)
            local xPred = Options.XPrediction.Value
            local yPred = inAir and Options.YPrediction.Value or 0
            
            local predictedPos = bestPart.Position + (bestPart.AssemblyLinearVelocity * Vector3.new(xPred, yPred, 0))
            
            local desired = CFrame.new(Camera.CFrame.Position, predictedPos)
            local avgSmooth = (Options.XSmoothing.Value + Options.YSmoothing.Value) / 2
            local alpha = math.clamp(dt * (10 / math.max(0.001, avgSmooth)), 0, 1)
            
            Camera.CFrame = Camera.CFrame:Lerp(desired, alpha)
        else
            if Camera.CameraType ~= Enum.CameraType.Custom then
                Camera.CameraType = Enum.CameraType.Custom
            end
        end
    end)
    
    table.insert(AimAssistInstance.connections, aimConnection)
    
end

Toggles.AimAssistEnabled:OnChanged(function()
    if Toggles.AimAssistEnabled.Value then
        initializeAimAssist()
    else
        if AimAssistInstance.fov then
            AimAssistInstance.fov:Remove()
        end
        if AimAssistInstance.connections then
            for _, connection in pairs(AimAssistInstance.connections) do
                if connection and connection.Disconnect then
                    connection:Disconnect()
                end
            end
        end
        if AimAssistInstance.hook then
            restoremetamethod(game, '__index', AimAssistInstance.hook)
        end
    end
end)

Options.AimKey:OnChanged(function()
    AimAssistEnabled = false
    if fov then
        fov:SetColor(Color3.fromRGB(255, 0, 0))
    end
end)

Library:SetWatermarkVisibility(true)
Library:SetWatermark('Aim Assist | LinoriaLib')

Library:OnUnload(function()
    if AimAssistInstance and AimAssistInstance.fov then
        AimAssistInstance.fov:Remove()
    end
    if AimAssistInstance and AimAssistInstance.connections then
        for _, connection in pairs(AimAssistInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
    if AimAssistInstance and AimAssistInstance.hook then
        restoremetamethod(game, '__index', AimAssistInstance.hook)
    end
    Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('AimAssistScript')
SaveManager:SetFolder('AimAssistScript/game')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()


-- loadstring(game:HttpGet('https://raw.githubusercontent.com/percxs/botsilent/refs/heads/main/inlinoria'))()
    
