if getgenv().SilentAimInstance then
    if getgenv().SilentAimInstance.fov then
        getgenv().SilentAimInstance.fov:Remove()
    end
    if getgenv().SilentAimInstance.connections then
        for _, connection in pairs(getgenv().SilentAimInstance.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
    end
end

getgenv().SilentAimInstance = {}

local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera
local RunService = game:GetService('RunService')

local function getClosestPart(character)
    if not character then return nil end
    
    local parts = {}
    local bodyParts = {
        'Head', 'HumanoidRootPart',
        'UpperTorso', 'LowerTorso',
        'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
        'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg',
        'LeftFoot', 'RightFoot', 'LeftHand', 'RightHand'
    }
    
    for _, partName in pairs(bodyParts) do
        local part = character:FindFirstChild(partName)
        if part then
            table.insert(parts, part)
        end
    end
    
    local closestPart = nil
    local closestDist = math.huge
    
    for _, part in pairs(parts) do
        local screenPos, onScreen = Camera:WorldToScreenPoint(part.Position)
        if onScreen then
            local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
            if dist < closestDist then
                closestDist = dist
                closestPart = part
            end
        end
    end
    
    return closestPart
end


local angleData = {angle = 0, distance = 0}

local function applyAntiCurve(targetPosition, cameraPosition)
    if not getgenv().Silent['Anti Curve'].Enabled then
        angleData.angle = 0
        angleData.distance = (targetPosition - cameraPosition).Magnitude
        return targetPosition
    end
    
    local maxAngle = math.rad(getgenv().Silent['Anti Curve']['Max Angle'])
    local distance = (targetPosition - cameraPosition).Magnitude
    
    local crosshairRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
    local targetDirection = (targetPosition - cameraPosition).Unit
    local crosshairDirection = crosshairRay.Direction
    
    local dotProduct = crosshairDirection:Dot(targetDirection)
    local actualAngle = math.acos(math.clamp(dotProduct, -1, 1))
    local actualAngleDegrees = math.deg(actualAngle)
    
    if math.random() < 0.3 then
        local randomAngleX = (math.random() - 0.5) * maxAngle
        local randomAngleY = (math.random() - 0.5) * maxAngle
        
        local rightVector = Camera.CFrame.RightVector
        local upVector = Camera.CFrame.UpVector
        
        local offsetX = rightVector * math.sin(randomAngleX) * distance * 0.1
        local offsetY = upVector * math.sin(randomAngleY) * distance * 0.1
        
        local curvedPosition = targetPosition + offsetX + offsetY
        
        angleData.angle = actualAngleDegrees
        angleData.distance = distance
        
        return curvedPosition
    else
        angleData.angle = actualAngleDegrees
        angleData.distance = distance
        return targetPosition
    end
end

local function getValidPlayers()
    local validPlayers = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoid = character:FindFirstChild('Humanoid')
            local rootPart = character:FindFirstChild('HumanoidRootPart')
            
            if humanoid and rootPart and humanoid.Health > 0 then
                local targetPart = nil
                if getgenv().Silent['Closest Mode'] then
                    targetPart = getClosestPart(character) or (character:FindFirstChild('Head') or rootPart)
                else
                    targetPart = character:FindFirstChild(getgenv().Silent.HitPart) or (character:FindFirstChild('Head') or rootPart)
                end
                
                if targetPart then
                    table.insert(validPlayers, {
                        player = player,
                        character = character,
                        targetPart = targetPart
                    })
                end
            end
        end
    end
    return validPlayers
end

local SilentAimEnabled = true

local fov = Drawing.new('Circle')
fov.Thickness = 1
fov.Radius = getgenv().Silent.FOV
fov.Color = Color3.fromRGB(0, 255, 0)
fov.Filled = false
fov.Transparency = 1
fov.Visible = getgenv().Silent['FOV Visible']
fov.Position = Vector2.new(Mouse.X, Mouse.Y + 55)

local lastPrintTime = 0

getgenv().SilentAimInstance.fov = fov
getgenv().SilentAimInstance.connections = {}

local renderConnection = RunService.RenderStepped:Connect(function()
    fov.Position = Vector2.new(Mouse.X, Mouse.Y + 55)
    fov.Visible = getgenv().Silent['FOV Visible']
    
    if getgenv().Silent['Anti Curve'].Visualize and SilentAimEnabled then
        local currentTime = tick()
        if currentTime - lastPrintTime > 0.1 then
            local maxAngle = getgenv().Silent['Anti Curve']['Max Angle']
            local currentAngle = angleData.angle
            local distance = angleData.distance
            local target = nil
            local targetPart = nil
            
            local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
            if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
                target = dummy
                targetPart = dummy.Head or dummy.HumanoidRootPart
            else
                local validPlayers = getValidPlayers()
                local closestDist = math.huge
                
                for _, playerData in pairs(validPlayers) do
                    local screenPos, onScreen = Camera:WorldToScreenPoint(playerData.targetPart.Position)
                    
                    if onScreen then
                        local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                        if dist < closestDist then
                            closestDist = dist
                            target = playerData.character
                            targetPart = playerData.targetPart
                        end
                    end
                end
            end
            
            if target and targetPart then
                local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
                local screenDist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                
                if onScreen and screenDist <= getgenv().Silent.FOV then
                    local crosshairRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
                    local targetDir = (targetPart.Position - Camera.CFrame.Position).Unit
                    local crosshairDir = crosshairRay.Direction
                    
                    local dot = crosshairDir:Dot(targetDir)
                    local angle = math.acos(math.clamp(dot, -1, 1))
                    local angleDeg = math.deg(angle)
                    
                    local charPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
                    local realDist = (targetPart.Position - charPos).Magnitude
                    
                end
            end
            
            lastPrintTime = currentTime
        end
    end
end)

table.insert(getgenv().SilentAimInstance.connections, renderConnection)

local keyConnection = Mouse.KeyDown:Connect(function(key)
    if key:lower() == getgenv().Silent.AimKey:lower() then
        SilentAimEnabled = not SilentAimEnabled
        fov.Color = SilentAimEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    end
end)

table.insert(getgenv().SilentAimInstance.connections, keyConnection)

local oldIndex
oldIndex = hookmetamethod(game, '__index', function(self, key)
    if self == Mouse and key:lower() == 'hit' and SilentAimEnabled then
        local target = nil
        local targetPart = nil
        
        local dummy = workspace:FindFirstChild('Bots') and workspace.Bots:FindFirstChild('Dummy')
        if dummy and dummy:FindFirstChild('HumanoidRootPart') and dummy:FindFirstChild('Humanoid') and dummy.Humanoid.Health > 0 then
            target = dummy
            if getgenv().Silent['Closest Mode'] then
                targetPart = getClosestPart(dummy) or (dummy.Head or dummy.HumanoidRootPart)
            else
                targetPart = dummy:FindFirstChild(getgenv().Silent.HitPart) or (dummy.Head or dummy.HumanoidRootPart)
            end
        else
            local validPlayers = getValidPlayers()
            local closestDist = math.huge
            
            for _, playerData in pairs(validPlayers) do
                local screenPos, onScreen = Camera:WorldToScreenPoint(playerData.targetPart.Position)
                
                if onScreen then
                    local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        target = playerData.character
                        targetPart = playerData.targetPart
                    end
                end
            end
        end
        
        if target and targetPart then
            local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
            local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude

            if onScreen and dist <= getgenv().Silent.FOV then
                local crosshairRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
                local targetDir = (targetPart.Position - Camera.CFrame.Position).Unit
                local crosshairDir = crosshairRay.Direction
                
                local dot = crosshairDir:Dot(targetDir)
                local angle = math.acos(math.clamp(dot, -1, 1))
                local angleDeg = math.deg(angle)
                
                local charPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character.HumanoidRootPart.Position or Camera.CFrame.Position
                local dist = (targetPart.Position - charPos).Magnitude
                
                if getgenv().Silent['Anti Curve'].Enabled then
                    if getgenv().Silent['Anti Curve'].Visualize then
                        print(string.format("TARGETING - Angle: %.1f° | Max: %.1f° | Within limit: %s", angleDeg, getgenv().Silent['Anti Curve']['Max Angle'], tostring(angleDeg <= getgenv().Silent['Anti Curve']['Max Angle'])))
                    end
                    if angleDeg <= getgenv().Silent['Anti Curve']['Max Angle'] then
                        if dist <= getgenv().Silent['Anti Curve']['Distance Threshold'] then
                            local predicted = targetPart.CFrame + (targetPart.AssemblyLinearVelocity * getgenv().Silent.Prediction)
                            local curvedPos = applyAntiCurve(predicted.Position, Camera.CFrame.Position)
                            return CFrame.new(curvedPos)
                        else
                            local predicted = targetPart.CFrame + (targetPart.AssemblyLinearVelocity * getgenv().Silent.Prediction)
                            return CFrame.new(predicted.Position)
                        end
                    end
                else
                    local predicted = targetPart.CFrame + (targetPart.AssemblyLinearVelocity * getgenv().Silent.Prediction)
                    return CFrame.new(predicted.Position)
                end
            end
        end
    end
    return oldIndex(self, key)
end)

getgenv().SilentAimInstance.hook = oldIndex
